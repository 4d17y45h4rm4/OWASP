# Testing for Format String

## Summary

A format string is a null-terminated character sequence that also contains conversion specifiers interpreted or converted at runtime. If server-side code [concatenates a user's input with a format string](https://www.netsparker.com/blog/web-security/string-concatenation-format-string-vulnerabilities/), an attacker can append additional conversion specifications to cause a runtime error, information disclosure, or buffer overflow.

The worst case for format strings vulnerabilities occur in languages that don't check arguments and also include a `%n` specifier that writes to memory. These functions, if exploited by an attacker modifying a format string, could cause [information disclosure and code execution](https://www.veracode.com/security/format-string):

* C and C++ [printf](https://en.cppreference.com/w/c/io/fprintf) and similar methods fprintf, sprintf, snprintf
* Perl [printf](https://perldoc.perl.org/functions/printf.html) and sprintf

These format string functions can't write to memory, but attackers can still cause information disclosure by changing format strings to output values the developers did not intend to send:

* Python 2.6 and 2.7 [str.format](https://docs.python.org/2/library/string.html) and Python 3 unicode [str.format](https://docs.python.org/3/library/stdtypes.html#str.format) can be modified by injecting strings that can point to [other variables](https://lucumr.pocoo.org/2016/12/29/careful-with-str-format/) in memory

The following format strings if modified can cause runtime errors if the attacker adds conversion specifier:

* Java [String.format](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#format%28java.util.Locale%2Cjava.lang.String%2Cjava.lang.Object...%29) and [PrintStream.format](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html#format%2528java.util.Locale%252Cjava.lang.String%252Cjava.lang.Object...%2529)
* PHP [printf](https://www.php.net/manual/es/function.printf.php)

The code pattern that causes a format string vulnerability is usually an append or concatenate to the format string argument of a _printf_ or _format_ function. The following example shows how a debug printf could cause the issue:

The example in C:

```c
// ...
char *userName = /* input from user controlled field */;

printf("DEBUG Current user: ");
// Vulnerable debugging code
printf(userName);
```

The example in Java:

```java
final String userName = /* input from user controlled field */;

System.out.printf("DEBUG Current user: ");
// Vulnerable code:
System.out.printf(userName);
```

In this particular example, if the attacker set their `userName` to have one or more conversion specifiers, there would be unwanted behaviour. The C example would [print out memory contents](https://www.defcon.org/images/defcon-18/dc-18-presentations/Haas/DEFCON-18-Haas-Adv-Format-String-Attacks.pdf) if `userName` contained `%p%p%p%p%p`, and it can corrupt memory contents if there is a `%n` in the string. In Java example, a `username` containing any specifier that needs an input including `%x` or `%s` would cause the program to crash with `IllegalArgumentException`. Although the examples are still subject to other problems, the vulnerability can be fixed by printf arguments of `printf("DEBUG Current user: %s", userName)`.

## Test Objectives

Assess whether injecting format string conversion specifiers into user-controlled fields causes undesired behaviour from the application.

## How to Test

### Static Analysis

Static analysis tools can find format string vulnerabilities in either the code or in binaries. Examples of tools include:

* C and C++: [Flawfinder](https://dwheeler.com/flawfinder/)
* Java: FindSecurityBugs rule [FORMAT_STRING_MANIPULATION](https://find-sec-bugs.github.io/bugs.htm#FORMAT_STRING_MANIPULATION)
* PHP: String formatter Analyzer in [phpsa](https://github.com/ovr/phpsa/blob/master/docs/05_Analyzers.md#function_string_formater)

### Manual Code Inspection

Static analysis may miss more subtle cases including format strings generated by complex code. To look for vulnerabilities manually in a codebase, a tester can look for all calls in the codebase that accept a format string and trace back to make sure untrusted input cannot change the format string.

### Conversion Specifier Injection

Testers can check at the unit test or full system test level by sending conversion specifiers in any string input. [Fuzz](https://owasp.org/www-community/Fuzzing) the program using all of the conversion specifiers for all languages the system under test uses. See the [OWASP Format string attack](https://owasp.org/www-community/attacks/Format_string_attack) page for possible inputs to use. If the test fails, the program will crash or display an unexpected output. If the test passes, the attempt to send a conversion specifier should be blocked, or the string should go through the system with no issues as with any other valid input.

Examples that follow assume the vulnerability is in query `x` in a site <https://vulnerable/userinfo?username=x>

#### Manual Injection

Testers can perform a manual test using a web browser or other web API debugging tools. Browse to the web application or site such that the query has conversion specifiers. Note that for C-like conversion specifiers, in URL queries, the `%` needs to be substituted for `%s`. Therefore, the test can be introduce a string of specifiers `%s%s%s%n` by browsing with the following URL:

<https://vulnerable/userinfo?username=%25s%25s%25s%25n>

If the web site is vulnerable, the browser or tool should receive an error, which may include a timeout or an HTTP return code 500.

The Java code returns the error

```
java.util.MissingFormatArgumentException: Format specifier '%s'
```

Depending on the C implementation, the process may crash completely with `Segmentation Fault`.

#### Automated Fuzzing

Fuzzing tools including wfuzz can automate injection tests. First, create a file with some valid inputs, a conversion specifier injection, and some more valid inputs. For wfuzz, testers can create a text file with one input per line, and without needing escape characters:

fuzz.txt

```
bob
%s%s%s%n
%p%p%p%p%p
{event.__init__.__globals__[CONFIG][SECRET_KEY]}
jane
```

The file contains two valid input `bob`, two C-like conversion specifiers, one Python conversion specifier to attempt to get global variables, and a valid input `jane`.

To send the fuzzing input file to the web application under test, use the following command:

```
wfuzz -c -z file,fuzz.txt,urlencode <://vulnerable/userinfo?username=FUZZ>
```

Note that the `urlencode` argument performs the approprate escaping for the strings.

An example output is as follows

```
===================================================================
ID           Response   Lines    Word     Chars       Payload
===================================================================

000000001:   200        0 L      1 W      3 Ch        "bob"
000000002:   500        0 L      5 W      142 Ch      "%25s%25s%25s%25n"
000000004:   200        0 L      1 W      48 Ch       "%7Bevent.__init__.__globals__%5BCONFIG%5D%5BSECRET_KEY%5D%7D"
000000003:   500        0 L      5 W      137 Ch      "%25p%25p%25p%25p%25p"
000000005:   200        0 L      1 W      4 Ch        "jane"

Total time: 0.075294
Processed Requests: 5
Filtered Requests: 0
```

This output shows that the target site is vulnerable to the injection of C-like `%s` and `%p` conversion specifiers, and it does not crash out completely if it encounters the injection.

* If the output has a normal response 200 for all the payloads, the application does not crash if sent a conversion specifer. Testers should still check if the fuzzing had any other effects on the application under test by running other sanity checks on the application after the fuzzing test.
* If the output does not return to normal after introducing the valid input after the invalid inputs, it means the application server became unstable after crashing due to the fuzzing test.

